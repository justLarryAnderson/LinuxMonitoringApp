ls -la /home/$USER | head -10

ps aux | grep -v grep | grep -i "gnome\|kde\|xfce" | head -15

find /home/$USER -name "*.txt" 2>/dev/null | head -8
Обработку ошибок (2>/dev/null) и ограничение вывода

netstat -tuln 2>/dev/null | grep LISTEN | head -5
Сетевые команды и фильтрацию состояний

ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head -7
Расширенные опции ps и форматирование

echo "User: $USER, Home: $HOME" && ls $HOME/Desktop 2>/dev/null | head -3
Работу с переменными окружения и комбинирование команд

for i in {1..10}; do echo "Line $i"; sleep 1; done
Возможность остановки длительных команд кнопкой "Стоп"








ОПИСАНИЕ файлов:

1. main.cpp
Точка входа в приложение - этот файл содержит минимальный код для запуска GTKmm приложения. Он создает экземпляр Gtk::Application, инициализирует главное окно и запускает главный цикл обработки событий. Файл является связующим звеном между операционной системой и логикой приложения, обеспечивая корректную инициализацию графической подсистемы и обработку аргументов командной строки. Основная функция main() создает экземпляр приложения с уникальным идентификатором "org.linux.systemmonitor", что позволяет системе управлять экземплярами приложения и их настройками.

2. MainWindow.h
Заголовочный файл главного окна - определяет структуру и интерфейс основного класса приложения MainWindow, который наследуется от Gtk::Window. В файле объявлены все элементы пользовательского интерфейса: контейнеры компоновки (Gtk::Box), кнопки управления, поля ввода, таблица процессов, область вывода текста и служебные элементы. Особое внимание уделено системе колонок для таблицы процессов (ModelColumns), которая определяет структуру отображаемых данных. Класс инкапсулирует бизнес-логику приложения, объединяя мониторинг процессов и выполнение команд через композицию объектов ProcessMonitor и CommandExecutor. Все обработчики событий объявлены как приватные методы, что обеспечивает четкое разделение интерфейса и реализации.

3. MainWindow.cpp
Реализация главного окна - содержит детальную реализацию всего функционала пользовательского интерфейса. В конструкторе происходит инициализация всех виджетов, настройка их свойств (размеры, placeholder-тексты, отступы) и компоновка в иерархическую структуру с помощью контейнеров Gtk::Box. Метод setupProcessTreeView() настраивает таблицу процессов, создавая колонки для PID, имени процесса, использования CPU и памяти, статуса, и устанавливает визуальные свойства. setupStyles() загружает CSS для кастомизации внешнего вида - устанавливает цвета, скругления, эффекты наведения. Обработчики событий реализуют реакцию на действия пользователя: обновление списка процессов, выполнение и остановку команд, фильтрацию, отображение справки. Метод showHelpDialog() создает кастомное диалоговое окно с темной темой и локализованным текстом помощи.

4. ProcessMonitor.h
Интерфейс мониторинга процессов - определяет API для работы с системными процессами. Структура ProcessInfo служит контейнером для данных о процессе, содержая строковые представления PID, имени, использования ресурсов и статуса. Класс ProcessMonitor предоставляет два основных публичных метода: getRunningProcesses() для получения списка всех процессов и findProcesses() для поиска по шаблону. Дизайн класса следует принципу единственной ответственности - он занимается исключительно получением и фильтрацией информации о процессах, не затрагивая вопросы отображения или выполнения команд. Интерфейс спроектирован для легкого расширения - при необходимости можно добавить новые методы фильтрации или сортировки без изменения существующего кода.

5. ProcessMonitor.cpp
Реализация мониторинга процессов - содержит логику взаимодействия с системными утилитами для получения информации о процессах. Метод getRunningProcesses() использует системный вызов popen() для выполнения команды ps aux --sort=-%cpu | head -20, которая возвращает 20 самых ресурсоемких процессов. Для безопасной работы с файловыми дескрипторами используется std::unique_ptr с кастомным deleter для автоматического закрытия канала. Полученный вывод парсится в parseProcessOutput(), где построчно обрабатывается, извлекаются данные и создаются объекты ProcessInfo. Метод findProcesses() реализует простую фильтрацию по подстроке в именах процессов. Особенность реализации - устойчивость к ошибкам формата вывода и обработка краевых случаев (пустые имена процессов).

6. CommandExecutor.h
Интерфейс выполнения команд - определяет контракт для выполнения системных команд. Класс предоставляет как синхронный (executeCommand()), так и асинхронный (executeCommandAsync()) интерфейсы, что позволяет гибко управлять выполнением длительных операций. Асинхронный метод использует callback-функции для уведомления о завершении, что соответствует идиомам GTKmm. Класс поддерживает отслеживание выполняемых процессов через вектор m_runningPids и предоставляет метод stopAllProcesses() для принудительной остановки. Дизайн учитывает необходимость работы с конвейерами shell и сложными командами, для чего используется выполнение через /bin/bash -c.

7. CommandExecutor.cpp
Реализация выполнения команд - содержит многопоточную логику выполнения системных команд. Синхронный метод executeCommand() оборачивает команду в вызов bash, что обеспечивает поддержку конвейеров, перенаправлений и shell-переменных. Особенность реализации - специальная обработка кода возврата для grep (код 1 считается успешным, так как означает "совпадения не найдены"). Асинхронный метод executeCommandAsync() использует std::thread для выполнения в фоновом потоке, предотвращая блокировку UI. После завершения команды результат передается в главный поток через Glib::signal_idle().connect_once(), что гарантирует безопасность работы с GTK. Метод stopAllProcesses() отправляет сигнал SIGTERM отслеживаемым процессам.

8. Makefile
Система сборки проекта - автоматизирует процесс компиляции и линковки приложения. Определяет компилятор (g++), флаги компиляции (C++17, предупреждения, пути к заголовкам GTKmm) и флаги линковки (библиотеки GTKmm, pthread). Использует шаблонные правила для компиляции .cpp файлов в объектные с автоматическим определением зависимостей. Ключевые особенности: флаг -pthread для поддержки многопоточности, использование pkg-config для автоматического определения путей и флагов GTKmm, создание папки build при необходимости. Makefile спроектирован для простоты расширения - добавление новых исходных файлов не требует изменения правил компиляции.
